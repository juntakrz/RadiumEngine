#version 460
#extension GL_EXT_nonuniform_qualifier : require

#include "include/common.glsl"

#define MAX_UNIQUE_PRIMITIVES 16384

#define PASS_OPAQUECULLBACK		8
#define PASS_OPAQUECULLNONE		16
#define PASS_DISCARDCULLNONE	32
//#define PASS_MASKCULLNONE		64			// Unused currently
#define PASS_BLENDCULLNONE		128

#define INVOCATION_PASS0		0
#define INVOCATION_PASS1		1
#define INVOCATION_PASS2		2
#define INVOCATION_PASS3		3
#define PASS_COUNT				4

struct ModelTransformBlock {
	mat4 matrix;
	mat4 prevMatrix;
};

struct NodeTransformBlock {
	mat4 matrix;
	float jointCount;
	mat4 prevMatrix;
	float padding[12];
};

struct UBOScene {
	mat4 view;
	mat4 projection;
	vec3 camPos;
	vec2 haltonJitter;
	vec2 clipData;			// x = near plane, y = far plane
	float padding[8];
};

struct DrawIndirectCommand {
	uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

struct InPrimitiveDataEntry {
	int vertexOffset;
	uint indexOffset;
	uint indexCount;
	uint instanceCount;
};

struct InInstanceDataEntry {
	vec4 AABBMin;
	vec4 AABBMax;
	uint modelMatrixId;
	uint nodeMatrixId;
	uint skinMatrixId;
	uint materialId;
	uint renderPassId;
	uint primitiveUId;
	bool isVisible;
};

struct OutInstanceDataEntry {
	uint modelMatrixId;
	uint nodeMatrixId;
	uint skinMatrixId;
	uint materialId;
};

layout (local_size_x = 32) in;

layout (set = 1, binding = 0) buffer readonly SceneDataBuffer {
	UBOScene sceneData[];
};

layout (set = 1, binding = 1) buffer readonly UBOMesh0 {
	ModelTransformBlock block[];
} model;

layout (set = 1, binding = 2) buffer readonly UBOMesh1 {
	NodeTransformBlock block[];
} node;

layout (set = 1, binding = 3) buffer coherent InstanceDataBuffer {
	InPrimitiveDataEntry inPrimitiveData[MAX_UNIQUE_PRIMITIVES];
	InInstanceDataEntry inInstanceData[];
};

layout (std430, set = 1, binding = 4) buffer writeonly OutDrawDataBuffer {
	DrawIndirectCommand outDrawCommands[];
};

layout (std430, set = 1, binding = 5) buffer writeonly OutInstanceDataBuffer {
	OutInstanceDataEntry outInstanceData[];
};

layout (std430, set = 1, binding = 6) buffer OutDrawCountBuffer {
	uint passDrawCount[PASS_COUNT];
	uint passInstanceCount[PASS_COUNT];
} outDrawCountBuffer;

layout (push_constant) uniform PushBlock {
	uint imageIndex;
	uint samplerIndex;
	uint bufferIndex;
	uint padding;
    ivec4 intValues;	// x - total number of instances, y - max primitiveUId, z - camera buffer block index
	vec4 floatValues;
} pushBlock;

bool isBoxInFrustum(vec4 boxMin, vec4 boxMax, mat4 transform) {
	// Construct a bounding box
	vec4 boxCorners[8];
	boxCorners[0] = vec4(boxMin.x, boxMax.y, boxMax.z, 1.0);		//		0		1
	boxCorners[1] = vec4(boxMax.x, boxMax.y, boxMax.z, 1.0);		//	2		3
	boxCorners[2] = vec4(boxMin.x, boxMax.y, boxMin.z, 1.0);
	boxCorners[3] = vec4(boxMax.x, boxMax.y, boxMin.z, 1.0);		//		4		5
	boxCorners[4] = vec4(boxMin.x, boxMin.y, boxMax.z, 1.0);		//	6		7
	boxCorners[5] = vec4(boxMax.x, boxMin.y, boxMax.z, 1.0);
	boxCorners[6] = vec4(boxMin.x, boxMin.y, boxMin.z, 1.0);
	boxCorners[7] = vec4(boxMax.x, boxMin.y, boxMin.z, 1.0);

	for (int i = 0; i < 8; i++) {
		vec4 transformedCorner = transform * boxCorners[i];

		if (transformedCorner.w == 0.0) {
			return true;
		}

		if ((transformedCorner.x > -transformedCorner.w && transformedCorner.x < transformedCorner.w)
			|| (transformedCorner.y > -transformedCorner.w && transformedCorner.y < transformedCorner.w)
			|| (transformedCorner.z > 0.0 && transformedCorner.z < transformedCorner.w)) {
			return true;
		}
	}

	return false;
}

void checkRenderPass(uint renderPassId, uint primitiveUId) {
	uint result = renderPassId & PASS_OPAQUECULLBACK;

	if (result != 0) {
		atomicAdd(outDrawCountBuffer.passInstanceCount[INVOCATION_PASS0], 1);

		if (inPrimitiveData[primitiveUId].instanceCount == 1) {
			atomicAdd(outDrawCountBuffer.passDrawCount[INVOCATION_PASS0], 1);
		}
		
		return;
	}

	result = renderPassId & PASS_OPAQUECULLNONE;
	if (result != 0) {
		atomicAdd(outDrawCountBuffer.passInstanceCount[INVOCATION_PASS1], 1);

		if (inPrimitiveData[primitiveUId].instanceCount == 1) {
			atomicAdd(outDrawCountBuffer.passDrawCount[INVOCATION_PASS1], 1);
		}
		
		return;
	}

	result = renderPassId & PASS_DISCARDCULLNONE;
	if (result != 0) {
		atomicAdd(outDrawCountBuffer.passInstanceCount[INVOCATION_PASS2], 1);

		if (inPrimitiveData[primitiveUId].instanceCount == 1) {
			atomicAdd(outDrawCountBuffer.passDrawCount[INVOCATION_PASS2], 1);
		}
		
		return;
	}

	result = renderPassId & PASS_BLENDCULLNONE;
	if (result != 0) {
		atomicAdd(outDrawCountBuffer.passInstanceCount[INVOCATION_PASS3], 1);

		if (inPrimitiveData[primitiveUId].instanceCount == 1) {
			atomicAdd(outDrawCountBuffer.passDrawCount[INVOCATION_PASS3], 1);
		}
		
		return;
	}
}

uint passIndexToId(uint passIndex) {
	switch(passIndex) {
		case INVOCATION_PASS0: {
			return PASS_OPAQUECULLBACK;
		}

		case INVOCATION_PASS1: {
			return PASS_OPAQUECULLNONE;
		}

		case INVOCATION_PASS2: {
			return PASS_DISCARDCULLNONE;
		}

		case INVOCATION_PASS3: {
			return PASS_BLENDCULLNONE;
		}
	}
}

void main() {
	// If an invocation index is larger than a 'total number of instances - 1' then there's no need to proceed
	const int totalInstanceCount = pushBlock.intValues.x;

	if (gl_GlobalInvocationID.x > totalInstanceCount - 1) return;

	const uint instanceId = gl_GlobalInvocationID.x;
	const uint primitiveUId = inInstanceData[instanceId].primitiveUId;

	// Initialize with default values
	inPrimitiveData[primitiveUId].instanceCount = 0;

	if (instanceId == 0) {
		for (int passId = 0; passId < PASS_COUNT; passId++) {
			outDrawCountBuffer.passDrawCount[passId] = 0;
			outDrawCountBuffer.passInstanceCount[passId] = 0;
		}
	}

	memoryBarrier();
	barrier();

	// Precalculate occlusion related values
	const int cameraBlockIndex = pushBlock.intValues.z;

	mat4 transform = sceneData[cameraBlockIndex].projection * sceneData[cameraBlockIndex].view
		* model.block[inInstanceData[instanceId].modelMatrixId].matrix * node.block[inInstanceData[instanceId].nodeMatrixId].matrix;

	vec4 boxMin = inInstanceData[instanceId].AABBMin;
	vec4 boxMax = inInstanceData[instanceId].AABBMax;

	// Perform culling
	bool isVisible = isBoxInFrustum(boxMin, boxMax, transform);
	inInstanceData[instanceId].isVisible = isVisible;

	// Precalculate instance count
	if (isVisible) {
		atomicAdd(inPrimitiveData[primitiveUId].instanceCount, 1);
	}
	
	memoryBarrier();
	barrier();

	// Precalculate draw and instance count for every render pass
	if (isVisible) {
		checkRenderPass(inInstanceData[instanceId].renderPassId, primitiveUId);
	}

	// Culling is done, time to sort instance data to correctly follow draw commands and instance count per each
	if (gl_GlobalInvocationID.x > 0) return;

	memoryBarrier();
	barrier();

	//const uint passId = gl_GlobalInvocationID.x;
	const int maxPrimitiveCount = (pushBlock.intValues.y < MAX_UNIQUE_PRIMITIVES) ? pushBlock.intValues.y : MAX_UNIQUE_PRIMITIVES;

	// Fill out primitive and instance data that belongs to this pass
	uint outDrawIndex = 0;
	uint outInstanceIndex = 0;

	for (int passIndex = 0; passIndex < PASS_COUNT; passIndex++) {
		//const uint totalPassInstanceCount = outDrawCountBuffer.passInstanceCount[passIndex];
		uint checkPassId = passIndexToId(passIndex);
		uint passDrawCount = 0;

		// Iterate through every primitive and check if it has any visible instances
		for (int currentPrimitiveUId = 0; currentPrimitiveUId < maxPrimitiveCount; currentPrimitiveUId++) {
			if (inPrimitiveData[currentPrimitiveUId].instanceCount > 0) {
				uint requiredInstanceCount = inPrimitiveData[currentPrimitiveUId].instanceCount;
				const uint firstPrimitiveVisibleIndex = outInstanceIndex;

				// Find visible instances of this primitive and copy their data to the instance buffer
				for (int currentInstanceId = 0; currentInstanceId < totalInstanceCount; currentInstanceId++) {
					if (inInstanceData[currentInstanceId].primitiveUId == currentPrimitiveUId
						&& inInstanceData[currentInstanceId].isVisible) {
						const uint isCurrentRenderPass = inInstanceData[currentInstanceId].renderPassId & checkPassId;

						if (isCurrentRenderPass != 0) {
							outInstanceData[outInstanceIndex].modelMatrixId = inInstanceData[currentInstanceId].modelMatrixId;
							outInstanceData[outInstanceIndex].nodeMatrixId = inInstanceData[currentInstanceId].nodeMatrixId;
							outInstanceData[outInstanceIndex].skinMatrixId = inInstanceData[currentInstanceId].skinMatrixId;
							outInstanceData[outInstanceIndex].materialId = inInstanceData[currentInstanceId].materialId;

							outInstanceIndex++;
							requiredInstanceCount--;
						}
					}

					// No need to keep looking for instances of this primitive if all visible ones were found
					if (requiredInstanceCount == 0) {
						outDrawCommands[outDrawIndex].indexCount = inPrimitiveData[currentPrimitiveUId].indexCount;
						outDrawCommands[outDrawIndex].instanceCount = inPrimitiveData[currentPrimitiveUId].instanceCount;
						outDrawCommands[outDrawIndex].firstIndex = inPrimitiveData[currentPrimitiveUId].indexOffset;
						outDrawCommands[outDrawIndex].vertexOffset = inPrimitiveData[currentPrimitiveUId].vertexOffset;
						outDrawCommands[outDrawIndex].firstInstance = firstPrimitiveVisibleIndex;

						passDrawCount++;
						outDrawIndex++;
						break;
					}
				}
			}

			// No need to iterate through more primitives if all instance data for this pass was already filled
			//if (outInstanceIndex == totalPassInstanceCount) break;
		}

		outDrawCountBuffer.passDrawCount[passIndex] = passDrawCount;
	}
}