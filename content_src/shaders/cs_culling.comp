#version 460
#extension GL_EXT_nonuniform_qualifier : require

#include "include/common.glsl"

#define MAX_UNIQUE_PRIMITIVES 16384

#define PASS_SHADOW				1
#define PASS_DISCARDSHADOW		2
#define PASS_ENVSKYBOX			4
#define PASS_OPAQUECULLBACK		8
#define PASS_OPAQUECULLNONE		16
#define PASS_DISCARDCULLNONE	32
//#define PASS_MASKCULLNONE		64			// Unused currently
#define PASS_BLENDCULLNONE		128
#define PASS_SKYBOX				256

#define IDP_SHADOW				0
#define IDP_DISCARDSHADOW		1
#define IDP_ENVSKYBOX			2
#define IDP_OPAQUECULLBACK		3
#define IDP_OPAQUECULLNONE		4
#define IDP_DISCARDCULLNONE		5
#define IDP_BLENDCULLNONE		6
#define IDP_SKYBOX				7
#define PASS_COUNT				8

struct ModelTransformBlock {
	mat4 matrix;
	mat4 prevMatrix;
};

struct NodeTransformBlock {
	mat4 matrix;
	float jointCount;
	mat4 prevMatrix;
	float padding[12];
};

struct UBOScene {
	mat4 view;
	mat4 projection;
	vec3 camPos;
	vec2 haltonJitter;
	vec2 clipData;			// x = near plane, y = far plane
	float padding[8];
};

struct PrimitiveDataEntry {
	uint instanceCount;
};

struct InstanceDataEntry {
	vec4 AABBMin;
	vec4 AABBMax;
	uint modelMatrixId;
	uint nodeMatrixId;
	uint skinMatrixId;
	uint renderPassFlags;
	uint primitiveUId;
	bool isVisible;
};

layout (local_size_x = 32) in;

layout (set = 1, binding = 0) buffer readonly SceneDataBuffer {
	UBOScene sceneData[];
};

layout (set = 1, binding = 1) buffer readonly UBOMesh0 {
	ModelTransformBlock block[];
} model;

layout (set = 1, binding = 2) buffer readonly UBOMesh1 {
	NodeTransformBlock block[];
} node;

layout (set = 1, binding = 3) buffer coherent InstanceDataBuffer {
	PrimitiveDataEntry primitiveData[MAX_UNIQUE_PRIMITIVES];
	InstanceDataEntry instanceData[];
};

layout (std430, set = 1, binding = 4) buffer writeonly coherent OutDrawCountBuffer {
	uint passDrawCount[PASS_COUNT];
} outDrawCountBuffer;

layout (push_constant) uniform PushBlock {
	uint imageIndex;
	uint samplerIndex;
	uint bufferIndex;
	uint padding;
    ivec4 intValues;	// x - total number of instances, y - max primitiveUId, z - camera buffer block index
	vec4 floatValues;
} pushBlock;

const uint passIds[PASS_COUNT] = uint[PASS_COUNT](
	PASS_SHADOW, PASS_DISCARDSHADOW, PASS_ENVSKYBOX, PASS_OPAQUECULLBACK,
	PASS_OPAQUECULLNONE, PASS_DISCARDCULLNONE, PASS_BLENDCULLNONE, PASS_SKYBOX
);

bool isBoxInFrustum(vec4 boxMin, vec4 boxMax, mat4 transform) {
	// Construct a bounding box
	vec4 boxCorners[8];
	boxCorners[0] = vec4(boxMin.x, boxMax.y, boxMax.z, 1.0);		//		0		1
	boxCorners[1] = vec4(boxMax.x, boxMax.y, boxMax.z, 1.0);		//	2		3
	boxCorners[2] = vec4(boxMin.x, boxMax.y, boxMin.z, 1.0);
	boxCorners[3] = vec4(boxMax.x, boxMax.y, boxMin.z, 1.0);		//		4		5
	boxCorners[4] = vec4(boxMin.x, boxMin.y, boxMax.z, 1.0);		//	6		7
	boxCorners[5] = vec4(boxMax.x, boxMin.y, boxMax.z, 1.0);
	boxCorners[6] = vec4(boxMin.x, boxMin.y, boxMin.z, 1.0);
	boxCorners[7] = vec4(boxMax.x, boxMin.y, boxMin.z, 1.0);

	for (int i = 0; i < 8; i++) {
		vec4 transformedCorner = transform * boxCorners[i];

		if (transformedCorner.w == 0.0) {
			return true;
		}

		if ((transformedCorner.x > -transformedCorner.w && transformedCorner.x < transformedCorner.w)
			|| (transformedCorner.y > -transformedCorner.w && transformedCorner.y < transformedCorner.w)
			|| (transformedCorner.z > 0.0 && transformedCorner.z < transformedCorner.w)) {
			return true;
		}
	}

	return false;
}

void checkRenderPass(uint renderPassFlags) {
	uint result = 0;

	for (uint i = 0; i < PASS_COUNT; i++) {
		result = renderPassFlags & passIds[i];

		if (result != 0) {
			atomicAdd(outDrawCountBuffer.passDrawCount[i], 1);
		}
	}
}

void main() {
	// If an invocation index is larger than a 'total number of instances - 1' then there's no need to proceed
	const int totalInstanceCount = pushBlock.intValues.x;

	if (gl_GlobalInvocationID.x > totalInstanceCount - 1) return;

	const uint instanceId = gl_GlobalInvocationID.x;
	const uint primitiveUId = instanceData[instanceId].primitiveUId;

	primitiveData[primitiveUId].instanceCount = 0;

	if (instanceId == 0) {
		for (int i = 0; i < PASS_COUNT; i++) {
			outDrawCountBuffer.passDrawCount[i] = 0;
		}
	}

	memoryBarrier();
	barrier();

	// Precalculate occlusion related values
	const int cameraBlockIndex = pushBlock.intValues.z;

	mat4 transform = sceneData[cameraBlockIndex].projection * sceneData[cameraBlockIndex].view
		* model.block[instanceData[instanceId].modelMatrixId].matrix * node.block[instanceData[instanceId].nodeMatrixId].matrix;

	vec4 boxMin = instanceData[instanceId].AABBMin;
	vec4 boxMax = instanceData[instanceId].AABBMax;

	// Perform culling
	bool isVisible = isBoxInFrustum(boxMin, boxMax, transform);
	instanceData[instanceId].isVisible = isVisible;

	int instanceIndex = -1;

	if (isVisible) {
		instanceIndex = int(atomicAdd(primitiveData[primitiveUId].instanceCount, 1));

		if (instanceIndex == 0) {
			checkRenderPass(instanceData[instanceId].renderPassFlags);
		}
	}
}